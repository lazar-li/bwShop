######下面的是沙箱账号里面配置的

url  网址  `<https://openhome.alipay.com/platform/appDaily.htm?tab=info> `

APPID :2016102200735340  (重要)

配置 RSAS  

下载 支付宝开放平台手册   获取 应用的 公钥 

配置到 RSAS 里面  保存下来

下面的是  应用的的公钥

`MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAh+l7lPQRrXqadbMdan8fjWxg8Igrg1ZhsuXZgHa+ORs1RfuqpTcioe3JuVg+DFz+da+SjHOamdBo36FUpsWkDtDJoo+uFxbXel6Vtm7KbA/7UDVkyulw3Zo+ip7ItlTsahzKaYhnBGZIc4YyQibHC+LMkuYpAA4SQ+rvwsMAzygol7OqkYeXnT+yHuaJ4iOUlsFy1wQGLL9J7VSP0G6NO9pJyJVb1RlLoSrfNuIFE6l4LU22yR4qMWkTNGiELliASAtXW3aijSCGmGAFTZjEVQrRkEAowjg5ybNHhh1Uc6sNrZieTHfJO780Aj6DsJhcgx/JyIGaABeSliyy24uEkQIDAQAB `

下面的是 支付宝公钥

MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiKavmM2Dsa7zvm3aUrz/0eTwtLh6Nhl13Xtp7qd1JWTu+PCBfSMeYqj2VK0/v1lr7xN6MmaVPN7RPd92fQRP1jrd284sBCV89SYjdFGOTPpB4Gd4E7afLJiHBpO/VOIsRu2fVTU5pHfuNxT8ZJXebRLGysP4uMXAH7nA85QJly7z3gnLO9PoOBSoglx8GSqzPMEAvEBioHnmUARKYlLBbAHmGOSU63qMC4DKWqEONqZGwitQ6tswjlnbu6apjTtFtaE3oaXWADsNJg7vlnWCDtMPXLXSJ2dsy84XpZpqLv73iJ2jjrgewBB53Txx/5OClKVHWeKV0cvmRwTdQ1bdPQIDAQAB 



###然后我们沙箱 账号是用来支付款的



###### ##下面我们需要配置的 

​	1首先我们下载 

​		pip install pycryptodome

 2. 我们 首先在支付宝应用里面设置一个文件jia   在 trade  里面创建文件keys

    建立 3个文件  alipay_key_2048.txt（上面的支付宝公钥写入里面）    private_2048.txt （私钥）public_2048.txt(公钥)

    ### 有一个错误 

    2.1 我们需要在  

    ​	三个密钥 开头加上

    ​		-----BEGIN PRIVATE KEY-----

    ​	结尾 加上

    ​		-----END PRIVATE KEY-----

​	3 .我们需要配置 setting 设置

​		`# 支付宝相关的keyprivate_key_path = os.path.join(BASE_DIR, 'apps/trade/keys/private_2048.txt')ali_pub_key_path = os.path.join(BASE_DIR, 'apps/trade/keys/alipay_key_2048.txt')`

 4. 在支付宝的 文件  apps > utils > alipay.py

      4.1 写入自己的  APPID (支付宝沙箱ID) 

    ​	

    ```
    import json
    from datetime import datetime
    from Crypto.PublicKey import RSA
    from Crypto.Signature import PKCS1_v1_5
    from Crypto.Hash import SHA256
    from base64 import b64encode, b64decode
    from urllib.parse import quote_plus
    from urllib.parse import urlparse, parse_qs
    from urllib.request import urlopen
    from base64 import decodebytes, encodebytes
    
    
    class AliPay(object):
        """
        支付宝支付接口
        """
        def __init__(self, appid, app_notify_url, app_private_key_path,
                     alipay_public_key_path, return_url, debug=False):
            self.appid = appid
            self.app_notify_url = app_notify_url
            #私钥
            self.app_private_key_path = app_private_key_path
            self.app_private_key = None
            self.return_url = return_url
            with open(self.app_private_key_path) as fp:
                self.app_private_key = RSA.importKey(fp.read())
            #公钥
            self.alipay_public_key_path = alipay_public_key_path
            with open(self.alipay_public_key_path) as fp:
                self.alipay_public_key = RSA.import_key(fp.read())
    
    
            if debug is True:
                self.__gateway = "https://openapi.alipaydev.com/gateway.do"
            else:
                self.__gateway = "https://openapi.alipay.com/gateway.do"
    
        def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs):
            #请求参数
            biz_content = {
                "subject": subject,
                "out_trade_no": out_trade_no,
                "total_amount": total_amount,
                "product_code": "FAST_INSTANT_TRADE_PAY",
                # "qr_pay_mode":4
            }
            #允许传递更多参数，放到biz_content
            biz_content.update(kwargs)
            data = self.build_body("alipay.trade.page.pay", biz_content, self.return_url)
            return self.sign_data(data)
    
        def build_body(self, method, biz_content, return_url=None):
            #build_body主要生产消息的格式
            #公共请求参数
            data = {
                "app_id": self.appid,
                "method": method,
                "charset": "utf-8",
                "sign_type": "RSA2",
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "version": "1.0",
                "biz_content": biz_content
            }
    
            if return_url is not None:
                data["notify_url"] = self.app_notify_url
                data["return_url"] = self.return_url
    
            return data
    
        def sign_data(self, data):
            #签名
            data.pop("sign", None)
            # 排序后的字符串
            unsigned_items = self.ordered_data(data)
            #排完序后拼接起来
            unsigned_string = "&".join("{0}={1}".format(k, v) for k, v in unsigned_items)
            #这里得到签名的字符串
            sign = self.sign(unsigned_string.encode("utf-8"))
            #对url进行处理
            quoted_string = "&".join("{0}={1}".format(k, quote_plus(v)) for k, v in unsigned_items)
    
            # 获得最终的订单信息字符串
            signed_string = quoted_string + "&sign=" + quote_plus(sign)
            return signed_string
    
        #参数传进来一定要排序
        def ordered_data(self, data):
            complex_keys = []
            for key, value in data.items():
                if isinstance(value, dict):
                    complex_keys.append(key)
    
            # 将字典类型的数据dump出来
            for key in complex_keys:
                data[key] = json.dumps(data[key], separators=(',', ':'))
    
            return sorted([(k, v) for k, v in data.items()])
    
        def sign(self, unsigned_string):
            # 开始计算签名
            key = self.app_private_key
            #签名的对象
            signer = PKCS1_v1_5.new(key)
            #生成签名
            signature = signer.sign(SHA256.new(unsigned_string))
            # base64 编码，转换为unicode表示并移除回车
            sign = encodebytes(signature).decode("utf8").replace("\n", "")
            return sign
    
        def _verify(self, raw_content, signature):
            # 开始计算签名
            key = self.alipay_public_key
            signer = PKCS1_v1_5.new(key)
            digest = SHA256.new()
            digest.update(raw_content.encode("utf8"))
            if signer.verify(digest, decodebytes(signature.encode("utf8"))):
                return True
            return False
    
        def verify(self, data, signature):
            if "sign_type" in data:
                sign_type = data.pop("sign_type")
            # 排序后的字符串
            unsigned_items = self.ordered_data(data)
            message = "&".join(u"{}={}".format(k, v) for k, v in unsigned_items)
            return self._verify(message, signature)
    
    
    if __name__ == "__main__":
        return_url = 'http://127.0.0.1:8000/?total_amount=100.00&timestamp=2017-08-15+23%3A53%3A34&sign=e9E9UE0AxR84NK8TP1CicX6aZL8VQj68ylugWGHnM79zA7BKTIuxxkf%2FvhdDYz4XOLzNf9pTJxTDt8tTAAx%2FfUAJln4WAeZbacf1Gp4IzodcqU%2FsIc4z93xlfIZ7OLBoWW0kpKQ8AdOxrWBMXZck%2F1cffy4Ya2dWOYM6Pcdpd94CLNRPlH6kFsMCJCbhqvyJTflxdpVQ9kpH%2B%2Fhpqrqvm678vLwM%2B29LgqsLq0lojFWLe5ZGS1iFBdKiQI6wZiisBff%2BdAKT9Wcao3XeBUGigzUmVyEoVIcWJBH0Q8KTwz6IRC0S74FtfDWTafplUHlL%2Fnf6j%2FQd1y6Wcr2A5Kl6BQ%3D%3D&trade_no=2017081521001004340200204115&sign_type=RSA2&auth_app_id=2016080600180695&charset=utf-8&seller_id=2088102170208070&method=alipay.trade.page.pay.return&app_id=2016080600180695&out_trade_no=20170202185&version=1.0'
        o = urlparse(return_url)
        query = parse_qs(o.query)
        processed_query = {}
        ali_sign = query.pop("sign")[0]
    
    
    # 测试用例
        alipay = AliPay(
            # 沙箱里面的appid值
            appid="2016102200735340",
            #notify_url是异步的url
            app_notify_url="http://127.0.0.1:8000/",
            # 我们自己商户的密钥
            app_private_key_path="../trade/keys/private_2048.txt",
            # 支付宝的公钥
            alipay_public_key_path="../trade/keys/alipay_key_2048.txt",  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
            # debug为true时使用沙箱的url。如果不是用正式环境的url
            debug=True,  # 默认False,
            return_url="http://127.0.0.1:8000/alipay/return/"
        )
    
        for key, value in query.items():
            processed_query[key] = value[0]
        # print (alipay.verify(processed_query, ali_sign))
    
        # 直接支付:生成请求的字符串。
        url = alipay.direct_pay(
            # 订单标题
            subject="测试订单bw在线",
            # 我们商户自行生成的订单号
            out_trade_no="20200527BW",
            # 订单金额
            total_amount=10,
            #成功付款后跳转到的页面，return_url同步的url
            # return_url="http://127.0.0.1:8000/"
        )
        # 将生成的请求字符串拿到我们的url中进行拼接
        re_url = "https://openapi.alipaydev.com/gateway.do?{data}".format(data=url)
    
        print(re_url)
    ```

    

4.2 在 trade 里面 views 里面写入  注意 ：：：需要修改自己的沙箱ID:2016102200735340

```
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from rest_framework_jwt.authentication import JSONWebTokenAuthentication
from rest_framework.authentication import SessionAuthentication
from rest_framework import mixins

from utils.permissions import IsOwnerOrReadOnly
from .serializers import ShopCartSerializer, ShopCartDetailSerializer, OrderSerializer, OrderDetailSerializer
from .models import ShoppingCart, OrderInfo, OrderGoods


class ShoppingCartViewset(viewsets.ModelViewSet):
    """
    购物车功能
    list:
        获取购物车详情
    create：
        加入购物车
    delete：
        删除购物记录
    """
    permission_classes = (IsAuthenticated, IsOwnerOrReadOnly)
    authentication_classes = (JSONWebTokenAuthentication, SessionAuthentication)

    serializer_class = ShopCartSerializer

    lookup_field = "goods_id"

    def get_queryset(self):
        return ShoppingCart.objects.filter(user=self.request.user)

    def get_serializer_class(self):
        if self.action == 'list':
            return ShopCartDetailSerializer
        else:
            return ShopCartSerializer

    # 库存数-1
    def perform_create(self, serializer):
        shop_cart = serializer.save()
        goods = shop_cart.goods
        goods.goods_num -= shop_cart.nums
        goods.save()

    # 库存数+1
    def perform_destroy(self, instance):
        goods = instance.goods
        goods.goods_num += instance.nums
        goods.save()
        instance.delete()

    # 更新库存,修改可能是增加页可能是减少
    def perform_update(self, serializer):
        #首先获取修改之前的库存数量
        existed_record = ShoppingCart.objects.get(id=serializer.instance.id)
        existed_nums = existed_record.nums
        # 先保存之前的数据existed_nums
        saved_record = serializer.save()
        #变化的数量
        nums = saved_record.nums-existed_nums
        goods = saved_record.goods
        goods.goods_num -= nums
        goods.save()


class OrderViewset(mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.CreateModelMixin, mixins.DestroyModelMixin,
                   viewsets.GenericViewSet):
    """
    订单管理
    list:
        获取个人订单
    delete:
        删除订单
    create：
        新增订单
    """
    permission_classes = (IsAuthenticated, IsOwnerOrReadOnly)
    authentication_classes = (JSONWebTokenAuthentication, SessionAuthentication)
    serializer_class = OrderSerializer

    # 动态配置serializer
    def get_serializer_class(self):
        if self.action == "retrieve":
            return OrderDetailSerializer
        return OrderSerializer

    # 获取订单列表
    def get_queryset(self):
        return OrderInfo.objects.filter(user=self.request.user)

    # 在订单提交保存之前还需要多两步步骤，所以这里自定义perform_create方法
    # 1.将购物车中的商品保存到OrderGoods中
    # 2.清空购物车
    def perform_create(self, serializer):
        order = serializer.save()
        # 获取购物车所有商品
        shop_carts = ShoppingCart.objects.filter(user=self.request.user)
        for shop_cart in shop_carts:
            order_goods = OrderGoods()
            order_goods.goods = shop_cart.goods
            order_goods.goods_num = shop_cart.nums
            order_goods.order = order
            order_goods.save()
            # 清空购物车
            shop_cart.delete()
        return order


from datetime import datetime
from utils.alipay import AliPay
from rest_framework.views import APIView
from bwShop.settings import ali_pub_key_path, private_key_path
from rest_framework.response import Response

class AlipayView(APIView):
    def get(self, request):
        """
        处理支付宝的return_url返回
        """
        processed_dict = {}
        # 1. 获取GET中参数
        for key, value in request.GET.items():
            processed_dict[key] = value
        # 2. 取出sign
        sign = processed_dict.pop("sign", None)

        # 3. 生成ALipay对象
        alipay = AliPay(
            appid="2016101900726352",
            app_notify_url="http://127.0.0.1:8000/alipay/return/",
            app_private_key_path=private_key_path,
            alipay_public_key_path=ali_pub_key_path,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
            debug=True,  # 默认False,
            return_url="http://127.0.0.1:8000/alipay/return/"
        )

        verify_re = alipay.verify(processed_dict, sign)

        # 这里可以不做操作。因为不管发不发return url。notify url都会修改订单状态。
        if verify_re is True:
            order_sn = processed_dict.get('out_trade_no', None)
            trade_no = processed_dict.get('trade_no', None)
            trade_status = processed_dict.get('trade_status', None)

            existed_orders = OrderInfo.objects.filter(order_sn=order_sn)
            for existed_order in existed_orders:
                existed_order.pay_status = trade_status
                existed_order.trade_no = trade_no
                existed_order.pay_time = datetime.now()
                existed_order.save()


    def post(self, request):
        """
        处理支付宝的notify_url
        """
        #存放post里面所有的数据
        processed_dict = {}
        #取出post里面的数据
        for key, value in request.POST.items():
            processed_dict[key] = value
        #把signpop掉，文档有说明
        sign = processed_dict.pop("sign", None)

        #生成一个Alipay对象
        alipay = AliPay(
            appid="2016102200735340",
            app_notify_url="http://127.0.0.1:8000/alipay/return/",
            app_private_key_path=private_key_path,
            alipay_public_key_path=ali_pub_key_path,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
            debug=True,  # 默认False,
            return_url="http://127.0.0.1:8000/alipay/return/"
        )

        #进行验证
        verify_re = alipay.verify(processed_dict, sign)

        # 如果验签成功
        if verify_re is True:
            #商户网站唯一订单号
            order_sn = processed_dict.get('out_trade_no', None)
            #支付宝系统交易流水号
            trade_no = processed_dict.get('trade_no', None)
            #交易状态
            trade_status = processed_dict.get('trade_status', None)

            # 查询数据库中订单记录
            existed_orders = OrderInfo.objects.filter(order_sn=order_sn)
            for existed_order in existed_orders:
                # 订单商品项
                order_goods = existed_order.goods.all()
                # 商品销量增加订单中数值
                for order_good in order_goods:
                    goods = order_good.goods
                    goods.sold_num += order_good.goods_num
                    goods.save()

                # 更新订单状态
                existed_order.pay_status = trade_status
                existed_order.trade_no = trade_no
                existed_order.pay_time = datetime.now()
                existed_order.save()
            #需要返回一个'success'给支付宝，如果不返回，支付宝会一直发送订单支付成功的消息
            return Response("success")
```

5  最后我们配置一下 在项目 里面 bwShop 里面的 url

```
from apps.trade.views import AlipayView
urlpatterns = [
    path('alipay/return/',AlipayView.as_view()),
]
```

